
## 1-2


## 1-5

**Check the output of racket `src/impl.rkt` and answer: After simulating how many cycles did you observe the first and the second instructions being committed? Could you explain the reason of these two cycle numbers based on the micro-architecture of the pretty secure processor?**


## 1-7


## 1-9

**Check the terminal output and answer: after finishing simulating which cycle does the implementation and specification start to mismatch on the architectural state? What is the mismatch? Why do we have this mismatch?**


## 1-11

**This time, what instruction triggers the mismatch on the architectural state at which cycle?**


## 2-2

**Describe the adder bug you found here.**


## 3-5

**What is the backdoor instruction you found? Take a screenshot of the terminal output at the cycle when this backdoor instruction is committed and include it into the report.**

![Screenshot of the output](./Screenshot.png)


## 3-6

**Based on your experience on lab6.A and lab6.B, how would you compare the pros and cons of fuzzing and formal verification techniques?**

